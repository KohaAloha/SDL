Scanning ./defines.h ...
Scanning ./helper.h ...
Scanning ./Image.xs ...
Scanning ./SDL.xs ...
Scanning ./SMPEG.xs ...
Scanning ./Core/Audio.xs ...
Scanning ./Core/CDROM.xs ...
Scanning ./Core/Events.xs ...
Scanning ./Core/Joystick.xs ...
Scanning ./Core/Mouse.xs ...
Scanning ./Core/MultiThread.xs ...
Scanning ./Core/Time.xs ...
Scanning ./Core/Video.xs ...
Scanning ./Core/objects/AudioCVT.xs ...
Scanning ./Core/objects/AudioSpec.xs ...
Scanning ./Core/objects/CD.xs ...
Scanning ./Core/objects/CDTrack.xs ...
Scanning ./Core/objects/Color.xs ...
Scanning ./Core/objects/Cursor.xs ...
Scanning ./Core/objects/Event.xs ...
Scanning ./Core/objects/keysym.xs ...
Scanning ./Core/objects/Overlay.xs ...
Scanning ./Core/objects/Palette.xs ...
Scanning ./Core/objects/PixelFormat.xs ...
Scanning ./Core/objects/Rect.xs ...
Scanning ./Core/objects/RWOps.xs ...
Scanning ./Core/objects/Surface.xs ...
Scanning ./Core/objects/Version.xs ...
Scanning ./Core/objects/VideoInfo.xs ...
Scanning ./GFX/BlitFunc.xs ...
Scanning ./GFX/FPSManager.xs ...
Scanning ./GFX/Framerate.xs ...
Scanning ./GFX/GFX.xs ...
Scanning ./GFX/ImageFilter.xs ...
Scanning ./GFX/Primitives.xs ...
Scanning ./GFX/Rotozoom.xs ...
Scanning ./Mixer/Channels.xs ...
Scanning ./Mixer/Effects.xs ...
Scanning ./Mixer/Groups.xs ...
Scanning ./Mixer/Mixer.xs ...
Scanning ./Mixer/Music.xs ...
Scanning ./Mixer/Samples.xs ...
Scanning ./Mixer/objects/MixChunk.xs ...
Scanning ./Mixer/objects/MixMusic.xs ...
Scanning ./Pango/Pango.xs ...
Scanning ./Pango/objects/Context.xs ...
Scanning ./SDLx/Layer.h ...
Scanning ./SDLx/Layer.xs ...
Scanning ./SDLx/LayerManager.h ...
Scanning ./SDLx/LayerManager.xs ...
Scanning ./SDLx/SFont.h ...
Scanning ./SDLx/SFont.xs ...
Scanning ./SDLx/Surface.xs ...
Scanning ./SDLx/Timer.h ...
Scanning ./SDLx/Timer.xs ...
Scanning ./SDLx/Validate.h ...
Scanning ./SDLx/Validate.xs ...
Scanning ./SDLx/Controller/Interface.h ...
Scanning ./SDLx/Controller/Interface.xs ...
Scanning ./SDLx/Controller/State.xs ...
Scanning ./support/darwin_support.h ...
Scanning ./support/win32.c ...
Scanning ./TTF/TTF.xs ...
Scanning ./TTF/objects/Font.xs ...
=== Analyzing ./defines.h ===
Uses eval_pv, which depends on G_SCALAR, GvSV, POPs, PUSHMARK, PUTBACK, SPAGAIN, SvPVx, SvREFCNT_dec, SvTRUE, croak, dSP, eval_sv, newSVpv
File needs eval_pv, adding static request
Needs to include 'ppport.h'
Analysis completed
Suggested changes:
--- ./defines.h
+++ ./defines.h.patched
@@ -1,3 +1,5 @@
+#define NEED_eval_pv
+#include "ppport.h"
 /* */
 /* defines.h */
 /* */
=== Analyzing ./helper.h ===
*** WARNING: Uses malloc, which may not be portable below perl 5.7.2, even with 'ppport.h'
*** WARNING: Uses ref, which may not be portable below perl 5.11.0, even with 'ppport.h'
Analysis completed (2 warnings)
Looks good
=== Analyzing ./Image.xs ===
Uses SvPV_nolen, which depends on SV_GMAGIC, SvPVX, sv_2pv_flags, sv_2pv
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./SDL.xs ===
*** Uses Perl_call_atexit instead of call_atexit
Uses PL_perl_destruct_level
Uses aTHX_
*** Uses 2 C++ style comments, which is not portable
Analysis completed
Suggested changes:
--- ./SDL.xs
+++ ./SDL.xs.patched
@@ -87,10 +87,10 @@
   void *array[10];
   size_t size;
 
-   //get void*'s for all entries on the stack
+   /*get void*'s for all entries on the stack */
      size = backtrace(array, 10);
   
-    // print out all the frames to stderr
+    /* print out all the frames to stderr */
          fprintf(stderr, "Error: signal %d:\n", sig);
            backtrace_symbols_fd(array, size, 2);
       exit(1);
@@ -179,7 +179,7 @@
 #ifndef WIN32
 #ifdef HAVE_TLS_CONTEXT 
 
-		Perl_call_atexit(PERL_GET_CONTEXT, (void*)sdl_perl_atexit,0);
+		call_atexit(PERL_GET_CONTEXT, (void*)sdl_perl_atexit,0);
 #else
 		atexit(sdl_perl_atexit);
 #endif
=== Analyzing ./SMPEG.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./Core/Audio.xs ===
Uses PTR2IV, which depends on INT2PTR, PTRV
Uses aTHX_
*** WARNING: Uses malloc, which may not be portable below perl 5.7.2, even with 'ppport.h'
Analysis completed (1 warning)
Looks good
=== Analyzing ./Core/CDROM.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./Core/Events.xs ===
Uses aTHX_
Uses call_sv, which depends on G_METHOD, SvPV_nolen_const, SV_CONST_RETURN, SV_GMAGIC, SvPVX_const, SvPVX, sv_2pv_flags, sv_2pv, aTHX_
*** WARNING: Uses malloc, which may not be portable below perl 5.7.2, even with 'ppport.h'
Analysis completed (1 warning)
Looks good
=== Analyzing ./Core/Joystick.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./Core/Mouse.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./Core/MultiThread.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./Core/Time.xs ===
Uses call_pv
Analysis completed
Looks good
=== Analyzing ./Core/Video.xs ===
Uses aTHX_
*** WARNING: Uses malloc, which may not be portable below perl 5.7.2, even with 'ppport.h'
Analysis completed (1 warning)
Looks good
=== Analyzing ./Core/objects/AudioCVT.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./Core/objects/AudioSpec.xs ===
Uses aTHX_
Uses call_pv
Uses newRV_inc, which depends on newRV
*** WARNING: Uses G_VOID, which may not be portable below perl 5.004, even with 'ppport.h'
Analysis completed (1 warning)
Looks good
=== Analyzing ./Core/objects/CD.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./Core/objects/CDTrack.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./Core/objects/Color.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./Core/objects/Cursor.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./Core/objects/Event.xs ===
Uses PL_na
Uses SvREFCNT_inc, which depends on PL_Sv, SvREFCNT
Uses XSRETURN, which depends on PL_stack_base, PL_stack_sp, STMT_END, STMT_START, ax
Uses aTHX_
Uses newRV_inc, which depends on newRV
Analysis completed
Looks good
=== Analyzing ./Core/objects/keysym.xs ===
Uses PL_na
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./Core/objects/Overlay.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./Core/objects/Palette.xs ===
Uses PTR2IV, which depends on INT2PTR, PTRV
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./Core/objects/PixelFormat.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./Core/objects/Rect.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./Core/objects/RWOps.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./Core/objects/Surface.xs ===
Uses aTHX_
Uses newRV_noinc, which depends on SvREFCNT_dec, newRV
Uses newSV_type, which depends on newSV, sv_upgrade
Analysis completed
Looks good
=== Analyzing ./Core/objects/Version.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./Core/objects/VideoInfo.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./GFX/BlitFunc.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./GFX/FPSManager.xs ===
Uses XSRETURN, which depends on PL_stack_base, PL_stack_sp, STMT_END, STMT_START, ax
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./GFX/Framerate.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./GFX/GFX.xs ===
Analysis completed
Looks good
=== Analyzing ./GFX/ImageFilter.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./GFX/Primitives.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./GFX/Rotozoom.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./Mixer/Channels.xs ===
Uses aTHX_
Uses call_sv, which depends on G_METHOD, SvPV_nolen_const, SV_CONST_RETURN, SV_GMAGIC, SvPVX_const, SvPVX, sv_2pv_flags, sv_2pv, aTHX_
*** WARNING: Uses G_VOID, which may not be portable below perl 5.004, even with 'ppport.h'
No need to define NEED_sv_2pv_flags when already needed globally
Analysis completed (1 warning)
Suggested changes:
--- ./Mixer/Channels.xs
+++ ./Mixer/Channels.xs.patched
@@ -1,7 +1,6 @@
 #include "EXTERN.h"
 #include "perl.h"
 #include "XSUB.h"
-#define NEED_sv_2pv_flags
 #include "ppport.h"
 
 #ifndef aTHX_
=== Analyzing ./Mixer/Effects.xs ===
Uses call_pv
*** WARNING: Uses G_VOID, which may not be portable below perl 5.004, even with 'ppport.h'
Analysis completed (1 warning)
Looks good
=== Analyzing ./Mixer/Groups.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./Mixer/Mixer.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./Mixer/Music.xs ===
Uses call_pv
*** WARNING: Uses G_VOID, which may not be portable below perl 5.004, even with 'ppport.h'
Analysis completed (1 warning)
Looks good
=== Analyzing ./Mixer/Samples.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./Mixer/objects/MixChunk.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./Mixer/objects/MixMusic.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./Pango/Pango.xs ===
Analysis completed
Looks good
=== Analyzing ./Pango/objects/Context.xs ===
Uses PL_na
Analysis completed
Looks good
=== Analyzing ./SDLx/Layer.h ===
Analysis completed
Looks good
=== Analyzing ./SDLx/Layer.xs ===
Uses SvREFCNT_inc, which depends on PL_Sv, SvREFCNT
Uses aTHX_
*** Uses 5 C++ style comments, which is not portable
Analysis completed
Suggested changes:
--- ./SDLx/Layer.xs
+++ ./SDLx/Layer.xs.patched
@@ -41,7 +41,7 @@
         if(SvROK(ST(items - 1)) && SVt_PVHV == SvTYPE(SvRV(ST(items - 1))))
         {
             RETVAL->data = (HV *)SvRV(ST(items - 1));
-            //if(SvREFCNT(RETVAL->data) < 2)
+            /*if(SvREFCNT(RETVAL->data) < 2) */
                 SvREFCNT_inc(RETVAL->data);
             items--;
         }
@@ -213,13 +213,13 @@
     CODE:
         SDLx_Layer        *layer   = (SDLx_Layer *)bag2obj(bag);
         SDLx_LayerManager *manager = layer->manager;
-        int index                  = layer->index; // we cant trust its value
+        int index                  = layer->index; /* we cant trust its value */
         layer->manager->saved = 0;
         int i;
         
         for(i = 0; i <= av_len(manager->layers); i++)
         {
-            if(*av_fetch(manager->layers, i, 0) == bag) // what bag do we have? => finding the right layer index
+            if(*av_fetch(manager->layers, i, 0) == bag) /* what bag do we have? => finding the right layer index */
             {
                 index = i;
                 break;
@@ -241,6 +241,6 @@
 layerx_DESTROY( layer )
     SDLx_Layer *layer
 CODE:
-        //if((HV *)NULL != layer->data) // Attempt to free unreferenced scalar
-            //SvREFCNT_dec(layer->data);
+        /*if((HV *)NULL != layer->data) // Attempt to free unreferenced scalar */
+            /*SvREFCNT_dec(layer->data); */
         safefree(layer);
=== Analyzing ./SDLx/LayerManager.h ===
Uses SvREFCNT_inc, which depends on PL_Sv, SvREFCNT
Needs to include 'ppport.h'
*** Uses 6 C++ style comments, which is not portable
Analysis completed
Suggested changes:
--- ./SDLx/LayerManager.h
+++ ./SDLx/LayerManager.h.patched
@@ -1,3 +1,4 @@
+#include "ppport.h"
 
 #include "helper.h"
 
@@ -26,26 +27,26 @@
 int intersection( SDLx_Layer *layer1, SDLx_Layer *layer2 )
 {
     if(
-        // upper left point inside layer
+        /* upper left point inside layer */
         (   layer1->pos->x <= layer2->pos->x
             && layer2->pos->x < layer1->pos->x + layer1->clip->w
             && layer1->pos->y <= layer2->pos->y
             && layer2->pos->y < layer1->pos->y + layer1->clip->h
         )
 
-        // upper right point inside layer
+        /* upper right point inside layer */
         || (   layer1->pos->x < layer2->pos->x + layer2->clip->w
             && layer2->pos->x + layer2->clip->w <= layer1->pos->x + layer1->clip->w
             && layer1->pos->y <= layer2->pos->y
             && layer2->pos->y < layer1->pos->y + layer1->clip->h )
 
-        // lower left point inside layer
+        /* lower left point inside layer */
         || (   layer1->pos->x <= layer2->pos->x
             && layer2->pos->x < layer1->pos->x + layer1->clip->w
             && layer1->pos->y < layer2->pos->y + layer2->clip->h
             && layer2->pos->y + layer2->clip->h <= layer1->pos->y + layer1->clip->h )
 
-        // lower right point inside layer
+        /* lower right point inside layer */
         || (   layer1->pos->x < layer2->pos->x + layer2->clip->w
             && layer2->pos->x + layer2->clip->w <= layer1->pos->x + layer1->clip->w
             && layer1->pos->y < layer2->pos->y + layer2->clip->h
@@ -69,7 +70,7 @@
         SDLx_Layer *layer2 = (SDLx_Layer *)bag2obj(bag);
         if(intersection( layer, layer2 ) || intersection( layer2, layer ))
         {
-            // TODO checking transparency
+            /* TODO checking transparency */
             SvREFCNT_inc(bag);
             av_store( matches, count, bag );
             count++;
@@ -104,7 +105,7 @@
         SDLx_Layer *layer2 = (SDLx_Layer *)bag2obj(bag);
         if(intersection( layer, layer2 ) || intersection( layer2, layer ))
         {
-            // TODO checking transparency
+            /* TODO checking transparency */
             SvREFCNT_inc(bag);
             av_store( matches, count, bag );
             count++;
=== Analyzing ./SDLx/LayerManager.xs ===
Uses SvREFCNT_inc, which depends on PL_Sv, SvREFCNT
Uses aTHX_
*** Uses 2 C++ style comments, which is not portable
Analysis completed
Suggested changes:
--- ./SDLx/LayerManager.xs
+++ ./SDLx/LayerManager.xs.patched
@@ -339,14 +339,14 @@
         {
             SDLx_Layer        *layer   = (SDLx_Layer *)bag2obj(ST(x));
             SDLx_LayerManager *manager = layer->manager;
-            int index                  = layer->index; // we cant trust its value
+            int index                  = layer->index; /* we cant trust its value */
             int i;
             
             SV *fetched;
             for(i = 0; i <= av_len(manager->layers); i++)
             {
                 fetched = *av_fetch(manager->layers, i, 0);
-                if(fetched == ST(x)) // what bag do we have? => finding the right layer index
+                if(fetched == ST(x)) /* what bag do we have? => finding the right layer index */
                 {
                     index = i;
                     break;
=== Analyzing ./SDLx/SFont.h ===
Analysis completed
Looks good
=== Analyzing ./SDLx/SFont.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./SDLx/Surface.xs ===
Uses aTHX_
Uses newRV_noinc, which depends on SvREFCNT_dec, newRV
Uses newSV_type, which depends on newSV, sv_upgrade
*** Uses 1 C++ style comment, which is not portable
Analysis completed
Suggested changes:
--- ./SDLx/Surface.xs
+++ ./SDLx/Surface.xs.patched
@@ -191,7 +191,7 @@
 		r_rect.y = v_rect->y;
 		r_rect.w = v_rect->w;
 		r_rect.h = v_rect->h;
-//		if( newly_created_rect == 1 ) {  safefree( v_rect); }
+/*		if( newly_created_rect == 1 ) {  safefree( v_rect); } */
 	}
     SDL_FillRect(surface, &r_rect, m_color);
 
=== Analyzing ./SDLx/Timer.h ===
Analysis completed
Looks good
=== Analyzing ./SDLx/Timer.xs ===
Uses XSRETURN, which depends on PL_stack_base, PL_stack_sp, STMT_END, STMT_START, ax
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./SDLx/Validate.h ===
Uses PL_sv_undef
Uses SvREFCNT_inc, which depends on PL_Sv, SvREFCNT
Uses SvUV, which depends on SvIOK, SvUVX, SvIVX, sv_2uv, PL_Sv, SvNOK, SvNV, sv_2nv
Uses newSVuv, which depends on newSViv, newSVnv
*** WARNING: Uses sv_derived_from, which may not be portable below perl 5.004, even with 'ppport.h'
Needs to include 'ppport.h'
*** Uses 1 C++ style comment, which is not portable
Analysis completed (1 warning)
Suggested changes:
--- ./SDLx/Validate.h
+++ ./SDLx/Validate.h.patched
@@ -1,10 +1,11 @@
+#include "ppport.h"
 #include <SDL.h>
 #include "helper.h"
 
 SV *rect( SV *rect, int* new_rect_made)
 {
     SV *retval = NULL;
-    //we hand this over to perl to handle
+    /*we hand this over to perl to handle */
 
     if( !SvOK(rect) )
     {
=== Analyzing ./SDLx/Validate.xs ===
Uses SvUV, which depends on SvIOK, SvUVX, SvIVX, sv_2uv, PL_Sv, SvNOK, SvNV, sv_2nv
Uses aTHX_
Uses newSVuv, which depends on newSViv, newSVnv
Analysis completed
Looks good
=== Analyzing ./SDLx/Controller/Interface.h ===
No need to include 'ppport.h'
*** Uses 8 C++ style comments, which is not portable
Analysis completed
Suggested changes:
--- ./SDLx/Controller/Interface.h
+++ ./SDLx/Controller/Interface.h.patched
@@ -1,23 +1,22 @@
-// Defines Controller Interface structs
-//
+/* Defines Controller Interface structs */
+/* */
 #include "EXTERN.h"
 #include "perl.h"
 #include "XSUB.h"
-#include "ppport.h"
 
 
 typedef struct SDLx_State
 {
-	// Position
+	/* Position */
 	float x; 
 	float y;
-	// Velocity
+	/* Velocity */
 	float v_x;
 	float v_y;
-	// Rotation
+	/* Rotation */
 	float rotation;
 	float ang_v; 
-	// owned by an object or not?
+	/* owned by an object or not? */
 	int owned;
 	
 } SDLx_State;
@@ -36,11 +35,11 @@
 typedef struct SDLx_Interface
 {
 
-	// states to hold
+	/* states to hold */
 	SDLx_State* previous;
 	SDLx_State* current;
 
-	// subs to callback 
+	/* subs to callback  */
 	SV* acceleration;
 	SV* evaluate;
 	SV* interpolate;
=== Analyzing ./SDLx/Controller/Interface.xs ===
Uses aTHX_
Uses call_sv, which depends on G_METHOD, SvPV_nolen_const, SV_CONST_RETURN, SV_GMAGIC, SvPVX_const, SvPVX, sv_2pv_flags, sv_2pv, aTHX_
Uses newRV_inc, which depends on newRV
*** WARNING: Uses malloc, which may not be portable below perl 5.7.2, even with 'ppport.h'
*** WARNING: Uses sv_nv, which may not be portable below perl 5.005, even with 'ppport.h'
*** Uses 5 C++ style comments, which is not portable
Analysis completed (2 warnings)
Suggested changes:
--- ./SDLx/Controller/Interface.xs
+++ ./SDLx/Controller/Interface.xs.patched
@@ -26,7 +26,7 @@
 	SV * stateref = newSV( sizeof(SDLx_State *) ); 	
 	void * copyState = safemalloc( sizeof(SDLx_State) );
 	memcpy( copyState, obj->current, sizeof(SDLx_State) );
-	((SDLx_State *)copyState)->owned = 0; //conditional free
+	((SDLx_State *)copyState)->owned = 0; /*conditional free */
 	ENTER;
 	SAVETMPS;
 	PUSHMARK(SP);
@@ -44,14 +44,14 @@
 	count = call_sv(obj->acceleration, G_ARRAY);
 
 	SPAGAIN;
-//	warn( "state %p, state->x %f", copyState, ((SDLx_State *)copyState)->x );
+/*	warn( "state %p, state->x %f", copyState, ((SDLx_State *)copyState)->x ); */
 	int i;
 	for( i =0; i < count ; i++)
 	 av_push( array, newSVnv(POPn));
 
-//	warn ("before obj->current->x %f", obj->current->x);
+/*	warn ("before obj->current->x %f", obj->current->x); */
 	copy_state(obj->current, (SDLx_State *)copyState);
-//	warn ("after obj->current->x %f", obj->current->x);
+/*	warn ("after obj->current->x %f", obj->current->x); */
 	FREETMPS;
 	LEAVE;
 
@@ -196,7 +196,7 @@
 	CODE:
 	 SDLx_State* out =  (SDLx_State *)safemalloc(sizeof(SDLx_State )) ;
 	 interpolate( obj,out, alpha);
-	 out->owned = 0; //condition free 
+	 out->owned = 0; /*condition free  */
 	 RETVAL = out;
 	 OUTPUT:
 	 RETVAL 
=== Analyzing ./SDLx/Controller/State.xs ===
Uses aTHX_
Analysis completed
Looks good
=== Analyzing ./support/darwin_support.h ===
Analysis completed
Looks good
=== Analyzing ./support/win32.c ===
Analysis completed
Looks good
=== Analyzing ./TTF/TTF.xs ===
Uses PL_na
*** WARNING: Uses sv_len_utf8, which may not be portable below perl 5.6.0, even with 'ppport.h'
Analysis completed (1 warning)
Looks good
=== Analyzing ./TTF/objects/Font.xs ===
Uses aTHX_
Analysis completed
Looks good
