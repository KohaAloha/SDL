=pod

=head1 NAME

SDL::Event - General event structure

=head1 SYNOPSIS

 use SDL::Event;                             # for the event object itself
 use SDL::Events qw(pump_events poll_event); # functions for event queue handling
 
 SDL::init(SDL_INIT_VIDEO);
 my $event = SDL::Event->new();
 
 while(1)
 {
     pump_events();

     if(poll_event($event))
     {
        if($event->type == SDL_MOUSEBUTTONDOWN)
        {
            # now you can handle the details
            $event->button_which;
            $event->button_button;
            $event->button_x;
            $event->button_y;
        }
        
        last if $event->type == SDL_QUIT;
     }

     # your screen drawing code will be here
 }
 
=head1 DESCRIPTION

Event handling allows your application to receive input from the user. 
Event handling is initalised (along with video) with a call to:

C<SDL::init(SDL_INIT_VIDEO);>

Internally, SDL stores all the events waiting to be handled in an event queue. 
Using functions like C<SDL::Events::poll_event()>, C<SDL::Events::peep_events> 
and C<SDL::Events::wait_event()> you can observe and handle waiting input events.

The key to event handling in SDL is the C<SDL::Event> union. 
The event queue itself is composed of a series of C<SDL::Event> unions, one for each waiting event. 
C<SDL::Event> unions are read from the queue with the C<SDL::Events::poll_event()> function 
and it is then up to the application to process the information stored with them. 

=head1	METHODS

=head2	new

C<new> creates an empty event-object, which can be used store information. 
Either by calling C<poll_event($event)> that transferes one event from the queue into our object 
or by setting all the needed data manually in order to push the event to the queue.

 use SDL::Event;

 my $event = SDL::Event->new();
 
=head2	type

SDL::Event is a union of all event structures used in SDL, using it is a simple matter of knowing 
which union member relates to which event C<type>.

 print 'heureka' if $event->type == SDL_MOUSEBUTTONDOWN;

Available type constants:

=over 4

=item *

L<SDL_ACTIVEEVENT|/active> - Application visibility event structure 

=item *

L<SDL_KEYDOWN|/active> - Keyboard event structure 

=item *

L<SDL_KEYUP|/active> - Keyboard event structure 

=item *

L<SDL_MOUSEMOTION|/active> - Mouse motion event structure 

=item *

L<SDL_MOUSEBUTTONDOWN|/active> - Mouse button event structure 

=item *

L<SDL_MOUSEBUTTONUP|/button> - Mouse button event structure 

=item *

L<SDL_JOYAXISMOTION|/active> - Joystick axis motion event structure 

=item *

L<SDL_JOYBALLMOTION|/active> - Joystick trackball motion event structure 

=item *

L<SDL_JOYHATMOTION|/active> - Joystick hat position change event structure 

=item *

L<SDL_JOYBUTTONDOWN|/active> - Joystick button event structure 

=item *

L<SDL_JOYBUTTONUP|/active> - Joystick button event structure 

=item *

L<SDL_VIDEORESIZE|/active> - Window resize event structure 

=item *

L<SDL_VIDEOEXPOSE|/active> - Window expose event 

=item *

L<SDL_QUIT|/active> - Quit requested event 

=item *

L<SDL_USEREVENT|/active> - A user-defined event type 

=item *

L<SDL_SYSWMEVENT|/active> - Platform-dependent window manager event. 

=back

Event types are grouped by masks. C<SDL_EVENTMASK($type)> will return the proper mask for the given C<type>.

Available event mask constants:

=over 4

=item *

SDL_ACTIVEEVENTMASK

=item *

SDL_KEYDOWNMASK

=item *

SDL_KEYUPMASK

=item *

SDL_KEYEVENTMASK

=item *

SDL_MOUSEMOTIONMASK

=item *

SDL_MOUSEBUTTONDOWNMASK

=item *

SDL_MOUSEBUTTONUPMASK

=item *

SDL_MOUSEEVENTMASK

=item *

SDL_JOYAXISMOTIONMASK

=item *

SDL_JOYBALLMOTIONMASK

=item *

SDL_JOYHATMOTIONMASK

=item *

SDL_JOYBUTTONDOWNMASK

=item *

SDL_JOYBUTTONUPMASK

=item *

SDL_JOYEVENTMASK

=item *

SDL_VIDEORESIZEMASK

=item *

SDL_VIDEOEXPOSEMASK

=item *

SDL_QUITMASK

=item *

SDL_SYSWMEVENTMASK

=back

This way you can check if a given C<type> matches a mask:

 (SDL_JOYBUTTONDOWN   & SDL_MOUSEEVENTMASK) # is false
 (SDL_MOUSEBUTTONDOWN & SDL_MOUSEEVENTMASK) # is true
 (SDL_MOUSEBUTTONUP   & SDL_MOUSEEVENTMASK) # is true
 (SDL_MOUSEMOTION     & SDL_MOUSEEVENTMASK) # is true
 
 # and also true is:
 
 (SDL_MOUSEEVENTMASK == SDL_EVENTMASK(SDL_MOUSEBUTTONDOWN) 
                      | SDL_EVENTMASK(SDL_MOUSEBUTTONUP) 
                      | SDL_EVENTMASK(SDL_MOUSEMOTION))

=head2 Application visibility events

C<active> is used when an event of type C<SDL_ACTIVEEVENT> is reported.

When the mouse leaves or enters the window area a C<SDL_APPMOUSEFOCUS> type activation event occurs, 
if the mouse entered the window then B<gain> will be 1, otherwise B<gain> will be 0. 

A C<SDL_APPINPUTFOCUS> type activation event occurs when the application loses or gains keyboard focus. 
This usually occurs when another application is made active. 

Finally, a C<SDL_APPACTIVE> type event occurs when the application is either minimised/iconified (B<gain>=0) or restored. 

A single event can have multiple values set in B<state>.

B<Note:> This event does not occur when an application window is first created. 

A new ActiveEvent (to fake focus loss) will be created like this:

 my $event = SDL::Event->new();
    $event->type(SDL_ACTIVEEVENT);
    $event->active_gain(0);
    $event->active_state(SDL_APPMOUSEFOCUS);

 # I think this is wrong, ->active_type() should get SDL_APPMOUSEFOCUS, but what state gets?

=head3 active_gain

See C<active>. 0 if the event is a loss or 1 if it is a gain.

=head3 active_state

A bitmask of the following values: SDL_APPMOUSEFOCUS if mouse focus was gained or lost, 
SDL_APPINPUTFOCUS if input focus was gained or lost, and SDL_APPACTIVE if the application was iconified (gain=0) or restored(gain=1).

=head2 Keyboard events

C<key> is used when an event of type C<SDL_KEYDOWN> or C<SDL_KEYUP> is reported.

The type and state actually report the same information, they just use different values to do it. 
A keyboard event generally occurs when a key is released (C<type=SDL_KEYUP> or C<key_state=SDL_RELEASED>) 
and when a key is pressed (C<type=SDL_KEYDOWN> or C<key_state=SDL_PRESSED>). 

The C<SDLK_CAPSLOCK> and C<SDLK_NUMLOCK> keys are special cases and report an C<SDL_KEYDOWN> when first pressed, 
then an C<SDL_RELEASED> when released and pressed again. For these keys C<KEYUP> and C<KEYDOWN> events are therefore 
analogous to the state of the caps lock and num lock LEDs rather than the keys themselves. 
These special cases are required for compatibility with Sun workstations.

B<Note:> Repeating C<SDL_KEYDOWN> events will occur if key repeat is enabled (see C<SDL_EnableKeyRepeat>). 

=head3 key_state

C<SDL_PRESSED> or C<SDL_RELEASED>

=head3 key_scancode

=head3 key_sym

=head3 key_mod

=head3 key_unicode

=head2 Mouse motion events

=head3 motion_state

=head3 motion_x, motion_y

=head3 motion_xrel, motion_yrel

=head2 Mouse button events

=head3 button_which

=head3 button_button

=head3 button_state

=head3 button_x, button_y

=head2 Joystick axis events

=head3 jaxis_which

=head3 jaxis_axis

=head3 jaxis_value

=head2 Joystick button events

=head3 jbutton_which

=head3 jbutton_button

=head3 jbutton_state

=head2 Joystick hat events

=head3 jhat_which

=head3 jhat_hat

=head3 jhat_value

=head2 Joystrick trackball events

=head3 jball_which

=head3 jball_ball

=head3 jball_xrel, jball_yrel

=head2 Window resize events

=head3 resize_x, resize_y

=head2 Window expose events

=head2 System window manager events

=head3 syswm_msg

=head2 User defined events

=head3 user_code

=head3 user_data1, user_data2

=head2 Quit event

Create a new SDL::Event object.

=head1 AUTHOR

=head1 SEE ALSO

L<perl>

=cut
